<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Maze Game</title>
		<style type="text/css">
			
		</style>
		<meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, width=device-width, user-scalable=no" />
	</head>
	<body onload="startGame()">
		<canvas id="gameCanvas" width="0" height="0"></canvas>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js" type="text/javascript"></script>
		<script type="text/javascript">	
			
			var testMode = false;
			function setupTestMode()
			{
				testMode = true;
				var counter = 0;
				for (let i = 0; i < map.length; i++)
				{
					for (let j = 0; j < map.length; j++)
					{
						if (monsterNames.includes(map[i][j]))
						{
							if (counter % 2 == 0)
							{
								map[i][j] = "Crocodile";
							}
							else
							{
								map[i][j] = "Ghost";
							}
							counter++;
						}
					}
				}
				gear[0] = "Flamethrower";
				gear[1] = "Cloak";
				gear[2] = "Crossbow";
				numCoins = 100;
				messagePrinter.setMessage("TEST!");
				
				drawCanvas(map);
			}
			
			var messagePrinter =
			{
				setMessage: function(message)
				{
					this.messageSet = true;
					this.messageText = message;
				},
				messageSet: false,
				messageText: "",
				printMessage: function()
				{
					alert(this.messageText);
					this.messageSet = false;
				}
			};
			
			var tilePositions = 
			{
				Tree1: 				{x:0, y:1},
				Tree2: 				{x:1, y:1},
				Tree3: 				{x:2, y:1},
				Tree4: 				{x:3, y:1},
				Tree5: 				{x:4, y:1},
				Tree6: 				{x:5, y:1},
				Tree7: 				{x:3, y:2},
				Tree0: 				{x:4, y:2},
				
				Coin:				{x:22, y:4},
				
				Chest:				{x:8, y:6},
				
				Player:				{x:31, y:1},
				
				Monster:			{x:24, y:5},
				
				Scorpian:			{x:24, y:5},
				Ghost:				{x:26, y:6},
				Skeleton:			{x:29, y:6},
				Ogre:				{x:30, y:6},
				Squid:				{x:25, y:8},
				Crocodile:			{x:29, y:8},
				Bear:				{x:30, y:8},
				Knight:				{x:31, y:0},
				
				Empty:				{x:0, y:0},
				
				NoGear:				{x:20, y:24},
				Torch:				{x:10, y:25},
				Cloak:				{x:15, y:24},
				Crossbow:			{x:6, y:27},
				Bomb:				{x:13, y:31},
				Flamethrower:		{x:10, y:31},
				Fire:				{x:15, y:10}
			}
			
			var gearInfo =
			{
				NoGear: {
					name: "None",
					desc: "Unused gear slot.",
					cost: 0
				},
				Torch: {
					name: "Torch",
					desc: "Stun adjacent monsters for 5 rounds.",
					cost: 15,
					use: function() {
						stunMonsterInPosition(playerY + 1, playerX, 6);
						stunMonsterInPosition(playerY - 1, playerX, 6);
						stunMonsterInPosition(playerY, playerX + 1, 6);
						stunMonsterInPosition(playerY, playerX - 1, 6);
					}
				},
				Flamethrower: {
					name: "Flamethrower",
					desc: "Create a slow-moving fireball ahead of you that deters monsters and spreads to trees.",
					cost: 20,
					use: function() {
						//If player hasn't moved or didn't move last turn, we can't use direction-based attacks.
						if ((playerMoveHistory.length == 0) 
						|| 
						(
							(playerMoveHistory[playerMoveHistory.length - 1][0] == 0) 
							&& (playerMoveHistory[playerMoveHistory.length - 1][1] == 0))
						)
						{
							numCoins += this.cost;
							return;
						}
						
						var mostRecentMove = playerMoveHistory[playerMoveHistory.length - 1];
						
						var locationToTest = 
							[playerX + mostRecentMove[0], 
							playerY + mostRecentMove[1]];
							
						if (locationToTest[0] < 0)
						{
							locationToTest[0] += map.length;
						}
						else if (locationToTest[0] >= map.length)
						{
							locationToTest[0] -= map.length;
						}
						if (locationToTest[1] < 0)
						{
							locationToTest[1] += map.length;
						}
						else if (locationToTest[1] >= map.length)
						{
							locationToTest[1] -= map.length;
						}
						
						var testLocationContents = map[locationToTest[1]][locationToTest[0]];
						
						if (moveableTileNames.includes(testLocationContents) || testLocationContents.includes("Tree") ||
						monsterNames.includes(testLocationContents.replace(/\$/g, "").replace(/\*/g, "")))
						{
							map[locationToTest[1]][locationToTest[0]] = "Fire" + parseInt(mostRecentMove[1]+1) + parseInt(mostRecentMove[0]+1) + "*"; //add 1 to avoid negatives, double digits, (-1) make substring parsing more complex
						}
						else
						{
							numCoins += this.cost;
							return;
						}
					}
				},
				Cloak: {
					name: "Cloak",
					desc: "Stun all monsters for 3 rounds.",
					cost: 45,
					use: function() {
						for (let i = 0; i < map.length; i++)
						{
							for (let j = 0; j < map.length; j++)
							{
								if (monsterNames.includes(map[i][j].replace(/\$/g, "").replace(/\*/g, "")))
								{
									stunMonsterInPosition(i, j, 4);
								}
							}
						}
					}
				},
				Bomb: {
					name: "Bag of Bombs",
					desc: "Destroy everything in a 3-tile radius.",
					cost: 70,
					use: function() {
						for (let i = playerY - 3; i <= playerY + 3; i++)
						{
							for (let j = playerX - 3; j <= playerX + 3; j++)
							{
								if (Math.abs(i - playerY) + Math.abs(j - playerX) <= 3)
								{
									var destroyI = i;
									if (destroyI < 0)
									{
										destroyI += map.length;
									}
									else if (destroyI >= map.length)
									{
										destroyI -= map.length;
									}
									var destroyJ = j;
									if (destroyJ < 0)
									{
										destroyJ += map.length;
									}
									else if (destroyJ >= map.length)
									{
										destroyJ -= map.length;
									}
									if (map[destroyI][destroyJ] != "Player")
									{
										map[destroyI][destroyJ] = "Empty";
									}
								}
							}
						}
					}
				},
				Crossbow: {
					name: "Crossbow",
					desc: "Stun a monster along a clear path directly ahead of you for 15 rounds.",
					cost: 10,
					use: function() {
						//If player hasn't moved or didn't move last turn, we can't use direction-based attacks.
						if ((playerMoveHistory.length == 0) 
						|| 
						(
							(playerMoveHistory[playerMoveHistory.length - 1][0] == 0) 
							&& (playerMoveHistory[playerMoveHistory.length - 1][1] == 0))
						)
						{
							numCoins += this.cost;
							return;
						}
						
						var mostRecentMove = playerMoveHistory[playerMoveHistory.length - 1];
						
						var locationToTest = 
							[playerX + mostRecentMove[0], 
							playerY + mostRecentMove[1]];
							
						if (locationToTest[0] < 0)
						{
							locationToTest[0] += map.length;
						}
						else if (locationToTest[0] >= map.length)
						{
							locationToTest[0] -= map.length;
						}
						if (locationToTest[1] < 0)
						{
							locationToTest[1] += map.length;
						}
						else if (locationToTest[1] >= map.length)
						{
							locationToTest[1] -= map.length;
						}
						
						var testLocationContents = map[locationToTest[1]][locationToTest[0]];
						
						while (moveableTileNames.includes(testLocationContents))
						{
							locationToTest[0] += mostRecentMove[0];
							locationToTest[1] += mostRecentMove[1];
							
							if (locationToTest[0] < 0)
							{
								locationToTest[0] += map.length;
							}
							else if (locationToTest[0] >= map.length)
							{
								locationToTest[0] -= map.length;
							}
							if (locationToTest[1] < 0)
							{
								locationToTest[1] += map.length;
							}
							else if (locationToTest[1] >= map.length)
							{
								locationToTest[1] -= map.length;
							}
							
							testLocationContents = map[locationToTest[1]][locationToTest[0]];
						}
						
						stunMonsterInPosition(locationToTest[1], locationToTest[0], 16);
					}
				}
			}
			
			function stunMonsterInPosition(i, j, numTurns)
			{
				var possibleMonsterName = map[i][j].replace(/\$/g, "");
				if (monsterNames.includes(possibleMonsterName))
				{
					for (let k = 0; k < numTurns; k++)
					{
						map[i][j] = map[i][j] + "$";
					}
				}
			}
			
			function getGearUIString(gearEntityName, button)
			{
				var UIStringArray = [];
				UIStringArray.push("[" + button + "]");
				UIStringArray.push(gearInfo[gearEntityName].name);
				UIStringArray.push("Cost: " +  gearInfo[gearEntityName].cost);
				UIStringArray.push("\"" + gearInfo[gearEntityName].desc + "\"");
				while(UIStringArray[UIStringArray.length - 1].length > 16)
				{
					var start = UIStringArray[UIStringArray.length - 1].substring(17, 0); //first 16 characters of last line
					var lastSpaceIndex = start.lastIndexOf(" "); //the index of the last space character in the first 17 characters
					var newLine = UIStringArray[UIStringArray.length - 1].substring(lastSpaceIndex);
					UIStringArray[UIStringArray.length - 1] = UIStringArray[UIStringArray.length - 1].substring(0, lastSpaceIndex);
					UIStringArray.push(newLine.trim());
				}
				return UIStringArray;
			}
			
			var moveableTileNames = [
				"Coin",
				"Chest",
				"Empty",
				"Player"
			];
			
			var monsterNames = [
					"Ghost",
					"Crocodile"/*,
					"Scorpian",
					"Skeleton",
					"Ogre",
					"Squid",
					"Bear",
					"Knight"*/
				];
			
			function generateMonsterName()
			{
				var generatedMonsterName = monsterNames[0];
				monsterNames.push(monsterNames.shift());
				console.log("Generated: " + generatedMonsterName);
				return generatedMonsterName;
			}
			
			var tileMapImg = new Image();
			tileMapImg.src = "tileset.png";
			
			var tileMapImg_flipped = new Image();
			tileMapImg_flipped.src = "tileset_flipped.png";
			
			var gameCanvas = document.getElementById("gameCanvas");
			var ctx = gameCanvas.getContext("2d");
			var chunkSize = 9;
			var chunksPerMap = 3; //should always be an odd number
			var mapSize = chunkSize * chunksPerMap;
			var tileSize = 32;
			var map;
			
			var emptySpaceBag = [];
			var emptySpaceBagIndex = 0;
			
			var playerTurn = true;
			var monsterTurn = false;
			
			var playerX = Math.floor(mapSize/2);
			var playerY = Math.floor(mapSize/2);
			
			var playerMoveHistory = []; //the player's last 10 moves
			var forecastedPlayerPosition = []; //where the player might be in 10 turns, based on playerMoveHistory
			
			var numCoins = 0;
			var gear = ["NoGear", "NoGear", "NoGear"];
			
			var emptyRoom_bitString = "TTTTETTTTTEEEEEEETTEEEEEEETTEEEEEEETEEEEEEEEETEEEEEEETTEEEEEEETTEEEEEEETTTTTETTTT";
			var target_bitStrip = "TTTTETTTTTEEEEEEETTETTTTTETTETEEETETEEEETEEEETETEEETETTETTTTTETTEEEEEEETTTTTETTTT";
			var hedge_bitStrip = "TTTTETTTTTETEEETETTEEETEEETTETEEETETEETTTTTEETETEEETETTEEETEEETTETEEETETTTTTETTTT";
			var pinwheel_bitStrip = "TTTTETTTTTEEEETEETTETTETTETTTTEEETETEEEEEEEEETETEEETTTTETTETTETTEETEEEETTTTTETTTT";
			var cross_bitStrip = "TTTTETTTTTEEEEEEETTEEETEEETTEEETEEETEETTTTTEETEEETEEETTEEETEEETTEEEEEEETTTTTETTTT";
			var butterfly_bitStrip = "TTTTETTTTTEETEEEETTEEEEEEETTTETTTETTEEETTTEEETTETTTETTTEEEEEEETTEETETEETTTTTETTTT";
			var ticTacToe_bitStrip = "TTTTETTTTTEEEEEEETTEETETEETTETTTTTETEEETTTEEETETTTTTETTEETETEETTEEEEEEETTTTTETTTT";
			var waves_bitStrip = "TTTTETTTTTEETEEEETTEEEETTETTTTEEETETEETETETEETETEEETTTTETTEEEETTEEEETEETTTTTETTTT";
			var gauntlet_bitStrip = "TTTTETTTTTEEEEEEETTETETTTETTETEEETETEETTTETEETETEEETETTETETTTETTETEEETETTTTTETTTT";
			var guillotine_bitStrip = "TTTTETTTTTEETETEETTEEEEEEETTETTETTETEEETETEEETETTETTETTETEEETETTEEEEEEETTTTTETTTT";
			var scarab_bitStrip = "TTTTETTTTTEEEEEEETTETETETETTETTTTTETEEETTTEEETETTTTTETTETETETETTEEEEEEETTTTTETTTT";
			var elephant_bitStrip = "TTTTETTTTTEEEEEEETTETTTETETTEETEETETEETTTTTEETETEETEETTETETTTETTEEEEEEETTTTTETTTT";
			var rosie_bitStrip = "TTTTETTTTTEEEEEEETTETTTTTETTETTTTTETEETTTTTEETETTTTTETTETTTTTETTEEEEEEETTTTTETTTT";
			var block_bitStrip = "TTTTETTTTTEEEEEEETTETTTTTETTETTTTTETEETTTTTEETETTTTTETTETTTTTETTEEEEEEETTTTTETTTT";
			var divide_bitStrip = "TTTTETTTTTEEEEEEETTETEEEEETTETTEEEETEEETTTEEETEEEETTETTEEEEETETTEEEEEEETTTTTETTTT";
			var pillars_bitStrip = "TTTTETTTTTEEEEEEETTETETETETTEEEEEEETEETETETEETEEEEEEETTETETETETTEEEEEEETTTTTETTTT";
			var moth_bitStrip = "TTTTETTTTTETEEETETTEEEEEEETTTEETEETTEEEETEEEETTEETEETTTEEEEEEETTETEEETETTTTTETTTT";
			var dub_bitStrip = "TTTTETTTTTEEEEEEETTETTETTETTETEEETETEETETETEETETETETETTETTTTTETTEEEEEEETTTTTETTTT";
			var ball_bitStrip = "TTTTETTTTTEEEEEEETTEETTTEETTETTTTTETEETTTTTEETETTTTTETTEETTTEETTEEEEEEETTTTTETTTT";
			
			var start_bitStrip = "TTTTETTTTTEEEEEEETTETTETTETTETEEETETEEEEPEEEETETEEETETTETTETTETTEEEEEEETTTTTETTTT";
			
			
			var target_bitString = "";
			
			function randomMazeChunk(addMonster)
			{
				var randInt = Math.floor(Math.random()*18);
				var bitString = "";
				switch(randInt)
				{
					case 0: return convertFromBitStringToChunk(rosie_bitStrip, addMonster);
					case 1: return convertFromBitStringToChunk(target_bitStrip, addMonster);
					case 2: return convertFromBitStringToChunk(hedge_bitStrip, addMonster);
					case 3: return convertFromBitStringToChunk(pinwheel_bitStrip, addMonster);
					case 4: return convertFromBitStringToChunk(scarab_bitStrip, addMonster);
					case 5: return convertFromBitStringToChunk(cross_bitStrip, addMonster);
					case 6: return convertFromBitStringToChunk(butterfly_bitStrip, addMonster);
					case 7: return convertFromBitStringToChunk(ticTacToe_bitStrip, addMonster);
					case 8: return convertFromBitStringToChunk(waves_bitStrip, addMonster);
					case 9: return convertFromBitStringToChunk(gauntlet_bitStrip, addMonster);
					case 10: return convertFromBitStringToChunk(guillotine_bitStrip, addMonster);
					case 11: return convertFromBitStringToChunk(block_bitStrip, addMonster);
					case 12: return convertFromBitStringToChunk(divide_bitStrip, addMonster);
					case 13: return convertFromBitStringToChunk(pillars_bitStrip, addMonster);
					case 14: return convertFromBitStringToChunk(moth_bitStrip, addMonster);
					case 15: return convertFromBitStringToChunk(dub_bitStrip, addMonster);
					case 16: return convertFromBitStringToChunk(ball_bitStrip, addMonster);
					case 17: return convertFromBitStringToChunk(elephant_bitStrip, addMonster);
					//default: return convertFromBitStringToChunk(guillotine_bitStrip);
				}
			}
			
			function convertFromBitStringToChunk(bitString, addMonster)
			{
				var chunk = [];
				var bs = bitString;
				
				if (addMonster)
				{
					var emptyCount = (bs.match(/E/g) || []).length;
					var matchIndexToReplace = Math.floor(Math.random()*emptyCount);
					var emptyCounter = 0;
					for (let i = 0; i < bs.length; i++)
					{
						if (bs.charAt(i) == "E")
						{
							if (emptyCounter == matchIndexToReplace)
							{
								bs = bitString.substr(0, i) + "M" + bitString.substr(i + 1);
								break;
							}
							else
							{
								emptyCounter++;
							}
						}
					}
				}
				
				for (let i = 0; i < chunkSize; i++)
				{
					var row = [];
					for (let j = 0; j < chunkSize; j++)
					{
						var c = bs.charAt(0);
						bs = bs.substring(1);
						switch(c)
						{
							case "E":
								if (emptySpaceBagIndex >= emptySpaceBag.length)
								{
									emptySpaceBag = shuffle(emptySpaceBag);
									emptySpaceBagIndex = 0;
								}
								row.push(emptySpaceBag[emptySpaceBagIndex]);
								emptySpaceBagIndex++;
								break;
							case "T":
								var randInt = Math.floor(Math.random() * 8);
								row.push("Tree" + randInt);
								break;
							case "P":
								row.push("Player");
								break;
							case "M":
								row.push(generateMonsterName());
								break;
							default:
								row.push("Empty");
								break;
						}
					}
					chunk.push(row);
				}
				return chunk;
			}
			
			function generateMap(type)
			{
				switch(type)
				{
					default:
					case "random maze":
						var arrayOfChunks = [];
						for (let i = 0; i < chunksPerMap; i++)
						{
							var rowOfChunks = [];
							for (let j = 0; j < chunksPerMap; j++)
							{
								var chunk;
								if ((i == Math.floor(chunksPerMap/2)) && (j == Math.floor(chunksPerMap/2)))
								{
									chunk = convertFromBitStringToChunk(start_bitStrip, false);
								}
								else if (((i == 0) && (j == 0)) 
								|| (((i == chunksPerMap-1) && (j == 0))) 
								|| (((i == 0) && (j == chunksPerMap-1))) 
								|| (((i == chunksPerMap-1) && (j == chunksPerMap-1))))
								{
									chunk = randomMazeChunk(true);
								}
								else
								{
									chunk = randomMazeChunk(false);
								}
								rowOfChunks.push(chunk);
							}
							arrayOfChunks.push(rowOfChunks);		
						}
						
						var maze = [];
						for (let i = 0; i < arrayOfChunks.length * arrayOfChunks[0][0].length; i++)
						{
							var mazeRow = [];
							for (let j = 0; j < arrayOfChunks[0].length * arrayOfChunks[0][0][0].length; j++)
							{
								var row = Math.floor(i/chunkSize);
								var col = Math.floor(j/chunkSize);
								var chunkRow = j%chunkSize;
								var chunkCol = i%chunkSize; 
								mazeRow.push(arrayOfChunks[row][col][chunkRow][chunkCol]);
							}
							maze.push(mazeRow);
						}
						
						return maze;
				}
			}
			
			function buildStartingEmptySpaceBag()
			{
				var bag = [];
				for (let i = 0; i < 10; i++)	// 10 Empty
				{
					bag.push("Empty");
				}
				for (let i = 0; i < 5; i++)		// 5 Coins
				{
					bag.push("Coin");
				}
				for (let i = 0; i < 1; i++)		// 1 Chest
				{
					bag.push("Chest");
				}
				return bag;
			}
			
			function startGame()
			{
				gameCanvas.width = (mapSize + 6)*tileSize;
				gameCanvas.height = mapSize*tileSize;
				
				emptySpaceBag = buildStartingEmptySpaceBag();
				
				map = generateMap("random maze");
				drawCanvas(map);
				
				emptySpaceBag = shuffle(emptySpaceBag);
				
				document.addEventListener('keydown', (e) => 
					{
						if (playerTurn)
						{
							if (e.code === "ArrowUp")
							{
								movePlayer(-1, 0);
							}
							else if (e.code === "ArrowDown")
							{
								movePlayer(1, 0);
							}
							else if (e.code === "ArrowLeft")
							{
								movePlayer(0, -1);
							}
							else if (e.code === "ArrowRight")
							{
								movePlayer(0, 1);
							}
							else if (e.code === "KeyA") //A
							{
								useGear(gear[0]);
							}
							else if (e.code === "KeyS") //S
							{
								useGear(gear[1]);
							}
							else if (e.code === "KeyD") //D
							{
								useGear(gear[2]);
							}
						}
					}
				);
				
				//Test
				setupTestMode();
				//Test
			}
			
			function useGear(gearName)
			{
				if (gearName != "NoGear")
				{
					var gear = gearInfo[gearName];
					if (gear.cost <= numCoins)
					{
						gear.use();
						numCoins -= gear.cost;
						gameTurn();
						drawCanvas(map);
					}
				}
			}
			
			function getChest()
			{
				console.log("Got a chest!");
			}
			
			function movePlayer(newX, newY)
			{
				var newPlayerX = playerX + newX;
				if (newPlayerX < 0)
				{
					newPlayerX += map.length;
				}
				else if (newPlayerX >= map.length)
				{
					newPlayerX -= map.length;
				}
				var newPlayerY = playerY + newY;
				if (newPlayerY < 0)
				{
					newPlayerY += map.length;
				}
				else if (newPlayerY >= map.length)
				{
					newPlayerY -= map.length;
				}
				
				var newSpace = map[newPlayerY][newPlayerX];
				
				if ((moveableTileNames.includes(newSpace)) || // the new space is a moveable tile
				( //or
					(monsterNames.includes(newSpace.replace(/\*/g, "").replace(/\$/g, "")))) //the new space contains a monster
					&& //and
					(newSpace.includes("$")) //it's stunned
				)
				{
					playerMoveHistory.push([newX, newY]);
					
					if (moveableTileNames.includes(newSpace))
					{
						map[playerY][playerX] = "Empty";
					}
					else
					{
						map[playerY][playerX] = newSpace;
					}
					playerX = newPlayerX;
					playerY = newPlayerY;
					map[playerY][playerX] = "Player";
					
					if (newSpace == "Coin")
					{
						numCoins++;
					}
					else if (newSpace == "Chest")
					{
						getChest();
					}
				}
				else
				{
					playerMoveHistory.push([0, 0]);
				}
				
				if (playerMoveHistory.length > 10)
				{
					playerMoveHistory.shift();
				}
				gameTurn();
				drawCanvas(map);
			}
			
			function forecastPlayerPosition()
			{
				forecastedPlayerPosition = [playerX, playerY];
				for (let i = 0; i < playerMoveHistory.length; i++)
				{
					forecastedPlayerPosition[0] = forecastedPlayerPosition[0] + playerMoveHistory[i][0];
					forecastedPlayerPosition[1] = forecastedPlayerPosition[1] + playerMoveHistory[i][1];
				}
				if (forecastedPlayerPosition[0] < 0)
				{
					forecastedPlayerPosition[0] += map.length;
				}
				else if (forecastedPlayerPosition[0] >= map.length)
				{
					forecastedPlayerPosition[0] -= map.length
				}
				if (forecastedPlayerPosition[1] < 0)
				{
					forecastedPlayerPosition[1] += map.length;
				}
				else if (forecastedPlayerPosition[1] >= map.length)
				{
					forecastedPlayerPosition[1] -= map.length
				}
			}
			
			function gameTurn()
			{
				buildPriorityMap(playerY, playerX, 0, []); //playerTargetted
				
				forecastPlayerPosition();
				buildPriorityMap(forecastedPlayerPosition[1], 
					forecastedPlayerPosition[0], 1, []); //playerForecasted
					
				buildPriorityMap(playerY, playerX, 2, monsterNames); //playerTargetted, avoiding all other monsters
				
				for (let i = 0; i < map.length; i++)
				{
					for (let j = 0; j < map[i].length; j++)
					{
						var mapEntity = map[i][j];
						if (monsterNames.includes(mapEntity.replace(/\$/g, "").replace(/\*/, "")))
						{
							moveMonster(map[i][j], i, j);
						}
						else if (mapEntity.includes("Fire"))
						{
							if (mapEntity.includes("*")) //if this is the first round that the fireball has existed, don't move it
							{
								map[i][j] = map[i][j].replace("*", "");
							}
							else
							{
								//burn down adjacent trees
								var adjacentCoordinates =
								[
									[0, 1],
									[0, -1],
									[1, 0],
									[-1, 0]
								]
								for (let k = 0; k < adjacentCoordinates.length; k++)
								{
									var targetI = i + adjacentCoordinates[k][0];
									if (targetI < 0)
									{
										targetI += map.length;
									}
									else if (targetI >= map.length)
									{
										targetI -= map.length;
									}
									var targetJ = j + adjacentCoordinates[k][1];
									if (targetJ < 0)
									{
										targetJ += map.length;
									}
									else if (targetJ >= map.length)
									{
										targetJ -= map.length;
									}
									var possibleTreeEntity = map[targetI][targetJ];
									if (map[targetI][targetJ].includes("Tree"))
									{
										// If this space hasn't been processed yet, make sure it doesn't try to move/spread
										map[targetI][targetJ] = "Fire11*"
									}
								}
								
								var fireDestination_i = i + parseInt(mapEntity.substring(4,5)) - 1;
								if (fireDestination_i < 0)
								{
									fireDestination_i += map.length;
								}
								else if (fireDestination_i >= map.length)
								{
									fireDestination_i -= map.length;
								}
								var fireDestination_j = j + parseInt(mapEntity.substring(5,6)) - 1;
								if (fireDestination_j < 0)
								{
									fireDestination_j += map.length;
								}
								else if (fireDestination_j >= map.length)
								{
									fireDestination_j -= map.length;
								}
								var targetEntity = map[fireDestination_i][fireDestination_j];
								
								if (targetEntity == "Player")
								{
									monsterEatsPlayer("Fire", fireDestination_i, fireDestination_j);
								}
								else if (targetEntity.includes("Tree"))
								{
									map[fireDestination_i][fireDestination_j] = "Fire11";
								}
								else if ((moveableTileNames.includes(targetEntity)) 
								|| (monsterNames.includes(targetEntity.replace(/\$/g, "").replace(/\*/g, ""))))
								{
									map[fireDestination_i][fireDestination_j] = map[i][j] + "*";
								}
								map[i][j] = "Empty";
							}
						}
					}
				}
			}
			
			var priorityMaps = [];
			priorityMaps.push([]); //playerTargeted
			priorityMaps.push([]); //playerForecasted
			priorityMaps.push([]); //playerTargeted, avoiding Monsters
			
			function buildPriorityMap(targetI, targetJ, priorityMapIndex, entitiesToAvoid)
			{
				priorityMaps[priorityMapIndex] = [];
				
				for (let i = 0; i < map.length; i++)
				{
					var row = [];
					for (let j = 0; j < map.length; j++)
					{
						row.push(map[i][j]);
					}
					priorityMaps[priorityMapIndex].push(row);
				}
				
				if (moveableTileNames.includes(map[targetI][targetJ]))
				{
					priorityMaps[priorityMapIndex][targetI][targetJ] = 0;
				}
				else
				{
					priorityMaps[priorityMapIndex][targetI][targetJ] = -1;
				}
				
				assignSpacePriority(targetI + 1, targetJ, 1, priorityMapIndex, entitiesToAvoid);
				assignSpacePriority(targetI - 1, targetJ, 1, priorityMapIndex, entitiesToAvoid);
				assignSpacePriority(targetI, targetJ + 1, 1, priorityMapIndex, entitiesToAvoid);
				assignSpacePriority(targetI, targetJ - 1, 1, priorityMapIndex, entitiesToAvoid);
				
				for (let i = 0; i < priorityMaps[priorityMapIndex].length; i++)
				{
					for (let j = 0; j < priorityMaps[priorityMapIndex].length; j++)
					{
						if (isNaN(parseInt(priorityMaps[priorityMapIndex][i][j])))
						{
							priorityMaps[priorityMapIndex][i][j] = -1;
						}
					}
				}
			}
			
			function compareSpacePriority(targetI, targetJ, testPriority, priorityMapIndex)
			{
				//This is used to determine if an adjacent space has already been prioritized.
				//If it has, and it has lower priority than we're testing, we'll use that +1
				//If it hasn't, we'll return the prio we're testing + 1, so that it won't be used
				if (targetI < 0)
				{
					targetI += map.length;
				}
				else if (targetI >= map.length)
				{
					targetI -= map.length;
				}
				if (targetJ < 0)
				{
					targetJ += map.length;
				}
				else if (targetJ >= map.length)
				{
					targetJ -= map.length;
				}
				var targetSpaceContents = priorityMaps[priorityMapIndex][targetI][targetJ];
				if ((!isNaN(parseInt(targetSpaceContents))) && (targetSpaceContents != -1))
				{
						return targetSpaceContents + 1;
				}
				else
				{
					return testPriority + 1;
				}
			}
			
			function assignSpacePriority(targetI, targetJ, newPriority, priorityMapIndex, entitiesToAvoid)
			{
				var adjustedNewPriority = newPriority;
				if (targetI < 0)
				{
					targetI += map.length;
				}
				else if (targetI >= map.length)
				{
					targetI -= map.length;
				}
				if (targetJ < 0)
				{
					targetJ += map.length;
				}
				else if (targetJ >= map.length)
				{
					targetJ -= map.length;
				}
				var targetSpaceContents = priorityMaps[priorityMapIndex][targetI][targetJ];
				if ((isNaN(parseInt(targetSpaceContents))) || ((targetSpaceContents > newPriority) && (targetSpaceContents != -1))) //this spaces hasn't been prioritized yet or it's been prioritized too high
				{
					if ((moveableTileNames.includes(targetSpaceContents))
						|| (monsterNames.includes(targetSpaceContents))
						|| (!isNaN(parseInt(targetSpaceContents))))
					{
						//Check all adjacent spaces, to see if they've been prioritized lower than this one will be prioritized. (to prevent snaking suboptimally due to iterating through map in order to prioritize)
						var adjacentPriority = compareSpacePriority(targetI + 1, targetJ, newPriority, priorityMapIndex);
						if (adjacentPriority < adjustedNewPriority)
						{
							adjustedNewPriority = adjacentPriority;
						}
						adjacentPriority = compareSpacePriority(targetI - 1, targetJ, newPriority, priorityMapIndex);
						if (adjacentPriority < adjustedNewPriority)
						{
							adjustedNewPriority = adjacentPriority;
						}
						adjacentPriority = compareSpacePriority(targetI, targetJ + 1, newPriority, priorityMapIndex);
						if (adjacentPriority < adjustedNewPriority)
						{
							adjustedNewPriority = adjacentPriority;
						}
						adjacentPriority = compareSpacePriority(targetI, targetJ - 1, newPriority, priorityMapIndex);
						if (adjacentPriority < adjustedNewPriority)
						{
							adjustedNewPriority = adjacentPriority;
						}
						
						if (entitiesToAvoid.includes(map[targetI][targetJ]))
						{
							adjustedNewPriority += 15;
						}
						priorityMaps[priorityMapIndex][targetI][targetJ] = adjustedNewPriority;
						assignSpacePriority(targetI + 1, targetJ, adjustedNewPriority + 1, priorityMapIndex, entitiesToAvoid);
						assignSpacePriority(targetI - 1, targetJ,  adjustedNewPriority + 1, priorityMapIndex, entitiesToAvoid);
						assignSpacePriority(targetI, targetJ + 1, adjustedNewPriority + 1, priorityMapIndex, entitiesToAvoid);
						assignSpacePriority(targetI, targetJ - 1, adjustedNewPriority + 1, priorityMapIndex, entitiesToAvoid);
					}
					else
					{
						priorityMaps[priorityMapIndex][targetI][targetJ] = -1;
					}
				}
			}
			
			function moveMonster(mapEntity, i, j)
			{
				if (mapEntity.includes("$"))
				{
					map[i][j] = mapEntity.replace("$", "");
				}
				else if (!mapEntity.includes("*"))
				{
					var targetSpaces = [];
					var monsterPriorityMapIndex
					switch(mapEntity)
					{
						case "Ghost":
							if (priorityMaps[0][i][j] < 3)
							{
								monsterPriorityMapIndex = 0;
							}
							else
							{
								monsterPriorityMapIndex = 1;
							}
							break;
						/*case "Skeleton":
							break;*/
						default:
							monsterPriorityMapIndex = 2;
							break;
					}
					
					var i_minus = i - 1;
					if (i_minus < 0)
					{
						i_minus += map.length;
					}
					targetSpaces.push(
						{
							space_i: 		i_minus,
							space_j: 		j,
							space_priority:	priorityMaps[monsterPriorityMapIndex][i_minus][j]
						}
					);
					var i_plus = i + 1;
					if (i_plus >= map.length)
					{
						i_plus -= map.length;
					}
					targetSpaces.push(
						{
							space_i: 		i_plus,
							space_j: 		j,
							space_priority:	priorityMaps[monsterPriorityMapIndex][i_plus][j]
						}
					);
					var j_minus = j - 1;
					if (j_minus < 0)
					{
						j_minus += map.length;
					}
					targetSpaces.push(
						{
							space_i: 		i,
							space_j: 		j_minus,
							space_priority:	priorityMaps[monsterPriorityMapIndex][i][j_minus]
						}
					);
					var j_plus = j + 1;
					if (j_plus >= map.length)
					{
						j_plus -= map.length;
					}
					targetSpaces.push(
						{
							space_i: 		i,
							space_j: 		j_plus,
							space_priority:	priorityMaps[monsterPriorityMapIndex][i][j_plus]
						}
					);
					targetSpaces = sort_by_key(targetSpaces, 'space_priority');
					
					var new_i = i;
					var new_j = j;
					
					for (let x = 0; x < targetSpaces.length; x++)
					{
						targetI = targetSpaces[x].space_i;
						targetJ = targetSpaces[x].space_j;
						var targetSpaceContents = map[targetI][targetJ];
						if (targetSpaceContents == "Player")
						{
							monsterEatsPlayer(mapEntity, targetI, targetJ);
						}
						if (moveableTileNames.includes(targetSpaceContents))
						{
							map[targetI][targetJ] = mapEntity + "*"; //already moved
							map[i][j] = targetSpaceContents;
							x = targetSpaces.length;
						}
					}
				}
			}
			
			function monsterEatsPlayer(monsterName, i, j)
			{
				if (testMode)
				{
					alert("You were eaten by a " + monsterName + "!");
				}
			}
			
			function drawCanvas(map)
			{
				for (let i = 0; i < map.length; i++)
				{
					for (let j = 0; j < map[0].length; j++)
					{
						var stunned = false;
						var entityNameToDraw = map[i][j].replace(/\$/g, "").replace(/\*/g, "");
						
						if (entityNameToDraw.includes("Fire"))
						{
							entityNameToDraw = "Fire";
						}
						
						if (map[i][j].includes("$"))
						{
							stunned = true;
						}
						
						if (map[i][j].includes("*"))
						{
							map[i][j] = map[i][j].replace(/\*/g, "");
						}

						if (stunned)
						{
							ctx.drawImage(
								tileMapImg_flipped,
								tilePositions[entityNameToDraw].x*(tileSize + 2),
								(31 - tilePositions[entityNameToDraw].y)*(tileSize + 2),
								tileSize, tileSize,
								i*tileSize,
								j*tileSize,
								tileSize, tileSize
							);
						}
						else
						{
							ctx.drawImage(
								tileMapImg,
								tilePositions[entityNameToDraw].x*(tileSize + 2),
								tilePositions[entityNameToDraw].y*(tileSize + 2),
								tileSize, tileSize,
								i*tileSize,
								j*tileSize,
								tileSize, tileSize
							);
						}
					}
				}
				//draw UI
				for (let i = 0; i < 6; i++)
				{
					for (let j = 0; j < map.length; j++)
					{
						ctx.drawImage(
							tileMapImg,
							tilePositions["Empty"].x*(tileSize + 2),
							tilePositions["Empty"].y*(tileSize + 2),
							tileSize, tileSize,
							(map.length + i) * tileSize,
							j*tileSize,
							tileSize, tileSize
						);
					}
				}
				
				var UIX = map.length*tileSize + 16;
				var UIY = 16;
				
				ctx.strokeStyle = '#cfc6b8';
				ctx.fillStyle = '#cfc6b8';
				ctx.lineWidth = 4;
				ctx.beginPath();
				ctx.rect(map.length*tileSize + 8, 8, 6*tileSize - 16, map.length*tileSize - 16);
				ctx.stroke();
				
				ctx.font = "16px Courier";
				ctx.fillText("Coins: " + numCoins, UIX, UIY + 16);
				ctx.fillText("Gear:", UIX, UIY + 48);
				
				var newlines = 0;
				var gearButtons = ['A', 'S', 'D'];
				for (let i = 0; i < gear.length; i++)
				{
					var UIStringArray = getGearUIString(gear[i], gearButtons[i]);
					ctx.drawImage(
							tileMapImg,
							tilePositions[gear[i]].x*(tileSize + 2),
							tilePositions[gear[i]].y*(tileSize + 2),
							tileSize, tileSize,
							UIX + 128,
							UIY + 60 + newlines*16,
							tileSize, tileSize
						);
					for (let j = 0; j < UIStringArray.length; j++)
					{
						ctx.fillText(UIStringArray[j], UIX, UIY + 80 + newlines*16);
						newlines++;
					}
					newlines++;
				}
				
				if (messagePrinter.messageSet)
				{
					messagePrinter.printMessage();
				}
				
			}
			
			function shuffle(array) { //from: https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
				var currentIndex = array.length, temporaryValue, randomIndex;

				// While there remain elements to shuffle...
				while (0 !== currentIndex) {

				// Pick a remaining element...
				randomIndex = Math.floor(Math.random() * currentIndex);
				currentIndex -= 1;

				// And swap it with the current element.
				temporaryValue = array[currentIndex];
				array[currentIndex] = array[randomIndex];
				array[randomIndex] = temporaryValue;
				}

				return array;
			}
			
			function sort_by_key(array, key) //from: https://stackoverflow.com/questions/8175093/simple-function-to-sort-an-array-of-objects/8175221#8175221
			{
			 return array.sort(function(a, b)
			 {
			  var x = a[key]; var y = b[key];
			  return ((x < y) ? -1 : ((x > y) ? 1 : 0));
			 });
			}
		</script>
	</body>
</html>
