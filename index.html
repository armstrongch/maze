<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Maze Game</title>
		<style type="text/css">
			
		</style>
		<meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, width=device-width, user-scalable=no" />
	</head>
	<body onload="startGame()">
		<canvas id="gameCanvas" width="0" height="0"></canvas>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js" type="text/javascript"></script>
		<script type="text/javascript">	
			
			var testMode = false;
			function setupTestMode()
			{
				testMode = true;
				var counter = 0;
				for (let i = 0; i < map.length; i++)
				{
					for (let j = 0; j < map.length; j++)
					{
						if (monsterNames.includes(map[i][j]))
						{
							if (counter % 2 == 0)
							{
								map[i][j] = "Crocodile";
							}
							else
							{
								map[i][j] = "Ghost";
							}
							counter++;
						}
					}
				}
				drawCanvas(map);
			}
			
			var tilePositions = 
			{
				Tree1: 				{x:0, y:1},
				Tree2: 				{x:1, y:1},
				Tree3: 				{x:2, y:1},
				Tree4: 				{x:3, y:1},
				Tree5: 				{x:4, y:1},
				Tree6: 				{x:5, y:1},
				Tree7: 				{x:3, y:2},
				Tree0: 				{x:4, y:2},
				
				Coin:				{x:22, y:4},
				
				Chest:				{x:8, y:6},
				
				Player:				{x:31, y:1},
				
				Monster:			{x:24, y:5},
				
				Scorpian:			{x:24, y:5},
				Ghost:				{x:26, y:6},
				Skeleton:			{x:29, y:6},
				Ogre:				{x:30, y:6},
				Squid:				{x:25, y:8},
				Crocodile:			{x:29, y:8},
				Bear:				{x:30, y:8},
				Knight:				{x:31, y:0},
				
				Empty:				{x:0, y:0}
			}
			
			var moveableTileNames = [
				"Coin",
				"Chest",
				"Empty",
				"Player"
			];
			
			var monsterNames = [
					"Scorpian",
					"Ghost",
					"Skeleton",
					"Ogre",
					"Squid",
					"Crocodile",
					"Bear",
					"Knight"
				];
			
			function generateMonsterName()
			{
				var randInt = Math.floor(Math.random() * monsterNames.length);
				return monsterNames[randInt];
			}
			
			var tileMapImg = new Image();
			tileMapImg.src = "tileset.png";
			var gameCanvas = document.getElementById("gameCanvas");
			var ctx = gameCanvas.getContext("2d");
			var chunkSize = 9;
			var chunksPerMap = 3; //should always be an odd number
			var mapSize = chunkSize * chunksPerMap;
			var tileSize = 32;
			var map;
			
			var emptySpaceBag = [];
			var emptySpaceBagIndex = 0;
			
			var playerTurn = true;
			var monsterTurn = false;
			
			var playerX = Math.floor(mapSize/2);
			var playerY = Math.floor(mapSize/2);
			
			var playerMoveHistory = []; //the player's last 10 moves
			var forecastedPlayerPosition = []; //where the player might be in 10 turns, based on playerMoveHistory
			
			var numCoins = 0;
			
			var emptyRoom_bitString = "TTTTETTTTTEEEEEEETTEEEEEEETTEEEEEEETEEEEEEEEETEEEEEEETTEEEEEEETTEEEEEEETTTTTETTTT";
			var target_bitStrip = "TTTTETTTTTEEEEEEETTETTTTTETTETEEETETEEEETEEEETETEEETETTETTTTTETTEEEEEEETTTTTETTTT";
			var hedge_bitStrip = "TTTTETTTTTETEEETETTEEETEEETTETEEETETEETTTTTEETETEEETETTEEETEEETTETEEETETTTTTETTTT";
			var pinwheel_bitStrip = "TTTTETTTTTEEEETEETTETTETTETTTTEEETETEEEEEEEEETETEEETTTTETTETTETTEETEEEETTTTTETTTT";
			var cross_bitStrip = "TTTTETTTTTEEEEEEETTEEETEEETTEEETEEETEETTTTTEETEEETEEETTEEETEEETTEEEEEEETTTTTETTTT";
			var butterfly_bitStrip = "TTTTETTTTTEETEEEETTEEEEEEETTTETTTETTEEETTTEEETTETTTETTTEEEEEEETTEETETEETTTTTETTTT";
			var ticTacToe_bitStrip = "TTTTETTTTTEEEEEEETTEETETEETTETTTTTETEEETTTEEETETTTTTETTEETETEETTEEEEEEETTTTTETTTT";
			var waves_bitStrip = "TTTTETTTTTEETEEEETTEEEETTETTTTEEETETEETETETEETETEEETTTTETTEEEETTEEEETEETTTTTETTTT";
			var gauntlet_bitStrip = "TTTTETTTTTEEEEEEETTETETTTETTETEEETETEETTTETEETETEEETETTETETTTETTETEEETETTTTTETTTT";
			var guillotine_bitStrip = "TTTTETTTTTEETETEETTEEEEEEETTETTETTETEEETETEEETETTETTETTETEEETETTEEEEEEETTTTTETTTT";
			var scarab_bitStrip = "TTTTETTTTTEEEEEEETTETETETETTETTTTTETEEETTTEEETETTTTTETTETETETETTEEEEEEETTTTTETTTT";
			var elephant_bitStrip = "TTTTETTTTTEEEEEEETTETTTETETTEETEETETEETTTTTEETETEETEETTETETTTETTEEEEEEETTTTTETTTT";
			var rosie_bitStrip = "TTTTETTTTTEEEEEEETTETTTTTETTETTTTTETEETTTTTEETETTTTTETTETTTTTETTEEEEEEETTTTTETTTT";
			var block_bitStrip = "TTTTETTTTTEEEEEEETTETTTTTETTETTTTTETEETTTTTEETETTTTTETTETTTTTETTEEEEEEETTTTTETTTT";
			var divide_bitStrip = "TTTTETTTTTEEEEEEETTETEEEEETTETTEEEETEEETTTEEETEEEETTETTEEEEETETTEEEEEEETTTTTETTTT";
			var pillars_bitStrip = "TTTTETTTTTEEEEEEETTETETETETTEEEEEEETEETETETEETEEEEEEETTETETETETTEEEEEEETTTTTETTTT";
			var moth_bitStrip = "TTTTETTTTTETEEETETTEEEEEEETTTEETEETTEEEETEEEETTEETEETTTEEEEEEETTETEEETETTTTTETTTT";
			var dub_bitStrip = "TTTTETTTTTEEEEEEETTETTETTETTETEEETETEETETETEETETETETETTETTTTTETTEEEEEEETTTTTETTTT";
			var ball_bitStrip = "TTTTETTTTTEEEEEEETTEETTTEETTETTTTTETEETTTTTEETETTTTTETTEETTTEETTEEEEEEETTTTTETTTT";
			
			var start_bitStrip = "TTTTETTTTTEEEEEEETTETTETTETTETEEETETEEEEPEEEETETEEETETTETTETTETTEEEEEEETTTTTETTTT";
			
			
			var target_bitString = "";
			
			function randomMazeChunk(addMonster)
			{
				var randInt = Math.floor(Math.random()*18);
				var bitString = "";
				switch(randInt)
				{
					case 0: return convertFromBitStringToChunk(rosie_bitStrip, addMonster);
					case 1: return convertFromBitStringToChunk(target_bitStrip, addMonster);
					case 2: return convertFromBitStringToChunk(hedge_bitStrip, addMonster);
					case 3: return convertFromBitStringToChunk(pinwheel_bitStrip, addMonster);
					case 4: return convertFromBitStringToChunk(scarab_bitStrip, addMonster);
					case 5: return convertFromBitStringToChunk(cross_bitStrip, addMonster);
					case 6: return convertFromBitStringToChunk(butterfly_bitStrip, addMonster);
					case 7: return convertFromBitStringToChunk(ticTacToe_bitStrip, addMonster);
					case 8: return convertFromBitStringToChunk(waves_bitStrip, addMonster);
					case 9: return convertFromBitStringToChunk(gauntlet_bitStrip, addMonster);
					case 10: return convertFromBitStringToChunk(guillotine_bitStrip, addMonster);
					case 11: return convertFromBitStringToChunk(block_bitStrip, addMonster);
					case 12: return convertFromBitStringToChunk(divide_bitStrip, addMonster);
					case 13: return convertFromBitStringToChunk(pillars_bitStrip, addMonster);
					case 14: return convertFromBitStringToChunk(moth_bitStrip, addMonster);
					case 15: return convertFromBitStringToChunk(dub_bitStrip, addMonster);
					case 16: return convertFromBitStringToChunk(ball_bitStrip, addMonster);
					case 17: return convertFromBitStringToChunk(elephant_bitStrip, addMonster);
					//default: return convertFromBitStringToChunk(guillotine_bitStrip);
				}
			}
			
			function convertFromBitStringToChunk(bitString, addMonster)
			{
				var chunk = [];
				var bs = bitString;
				
				if (addMonster)
				{
					var emptyCount = (bs.match(/E/g) || []).length;
					var matchIndexToReplace = Math.floor(Math.random()*emptyCount);
					var emptyCounter = 0;
					for (let i = 0; i < bs.length; i++)
					{
						if (bs.charAt(i) == "E")
						{
							if (emptyCounter == matchIndexToReplace)
							{
								bs = bitString.substr(0, i) + "M" + bitString.substr(i + 1);
								break;
							}
							else
							{
								emptyCounter++;
							}
						}
					}
				}
				
				for (let i = 0; i < chunkSize; i++)
				{
					var row = [];
					for (let j = 0; j < chunkSize; j++)
					{
						var c = bs.charAt(0);
						bs = bs.substring(1);
						switch(c)
						{
							case "E":
								if (emptySpaceBagIndex >= emptySpaceBag.length)
								{
									emptySpaceBag = shuffle(emptySpaceBag);
									emptySpaceBagIndex = 0;
								}
								row.push(emptySpaceBag[emptySpaceBagIndex]);
								emptySpaceBagIndex++;
								break;
							case "T":
								var randInt = Math.floor(Math.random() * 8);
								row.push("Tree" + randInt);
								break;
							case "P":
								row.push("Player");
								break;
							case "M":
								row.push(generateMonsterName());
								break;
							default:
								row.push("Empty");
								break;
						}
					}
					chunk.push(row);
				}
				return chunk;
			}
			
			function generateMap(type)
			{
				switch(type)
				{
					default:
					case "random maze":
						var arrayOfChunks = [];
						for (let i = 0; i < chunksPerMap; i++)
						{
							var rowOfChunks = [];
							for (let j = 0; j < chunksPerMap; j++)
							{
								var chunk;
								if ((i == Math.floor(chunksPerMap/2)) && (j == Math.floor(chunksPerMap/2)))
								{
									chunk = convertFromBitStringToChunk(start_bitStrip, false);
								}
								else if (((i == 0) && (j == 0)) 
								|| (((i == chunksPerMap-1) && (j == 0))) 
								|| (((i == 0) && (j == chunksPerMap-1))) 
								|| (((i == chunksPerMap-1) && (j == chunksPerMap-1))))
								{
									chunk = randomMazeChunk(true);
								}
								else
								{
									chunk = randomMazeChunk(false);
								}
								rowOfChunks.push(chunk);
							}
							arrayOfChunks.push(rowOfChunks);		
						}
						
						var maze = [];
						for (let i = 0; i < arrayOfChunks.length * arrayOfChunks[0][0].length; i++)
						{
							var mazeRow = [];
							for (let j = 0; j < arrayOfChunks[0].length * arrayOfChunks[0][0][0].length; j++)
							{
								var row = Math.floor(i/chunkSize);
								var col = Math.floor(j/chunkSize);
								var chunkRow = j%chunkSize;
								var chunkCol = i%chunkSize; 
								mazeRow.push(arrayOfChunks[row][col][chunkRow][chunkCol]);
							}
							maze.push(mazeRow);
						}
						
						return maze;
				}
			}
			
			function buildStartingEmptySpaceBag()
			{
				var bag = [];
				for (let i = 0; i < 10; i++)	// 10 Empty
				{
					bag.push("Empty");
				}
				for (let i = 0; i < 5; i++)		// 5 Coins
				{
					bag.push("Coin");
				}
				for (let i = 0; i < 1; i++)		// 1 Chest
				{
					bag.push("Chest");
				}
				return bag;
			}
			
			function startGame()
			{
				gameCanvas.width = mapSize*tileSize;
				gameCanvas.height = mapSize*tileSize;
				
				emptySpaceBag = buildStartingEmptySpaceBag();
				
				map = generateMap("random maze");
				drawCanvas(map);
				
				emptySpaceBag = shuffle(emptySpaceBag);
				
				document.addEventListener('keydown', (e) => 
					{
						if (playerTurn)
						{
							if (e.code === "ArrowUp")
							{
								movePlayer(-1, 0);
							}
							else if (e.code === "ArrowDown")
							{
								movePlayer(1, 0);
							}
							else if (e.code === "ArrowLeft")
							{
								movePlayer(0, -1);
							}
							else if (e.code === "ArrowRight")
							{
								movePlayer(0, 1);
							}
						}
					}
				);
				
				//Test
				setupTestMode();
				//Test
			}
			
			function getChest()
			{
				console.log("Got a chest!");
			}
			
			function movePlayer(newX, newY)
			{
				var newPlayerX = playerX + newX;
				if (newPlayerX < 0)
				{
					newPlayerX += map.length;
				}
				else if (newPlayerX >= map.length)
				{
					newPlayerX -= map.length;
				}
				var newPlayerY = playerY + newY;
				if (newPlayerY < 0)
				{
					newPlayerY += map.length;
				}
				else if (newPlayerY >= map.length)
				{
					newPlayerY -= map.length;
				}
				
				var newSpace = map[newPlayerY][newPlayerX];
				
				if (moveableTileNames.includes(newSpace))
				{
					playerMoveHistory.push([newX, newY]);
					
					map[playerY][playerX] = "Empty";
					playerX = newPlayerX;
					playerY = newPlayerY;
					map[playerY][playerX] = "Player";
					
					if (newSpace == "Coin")
					{
						numCoins++;
					}
					else if (newSpace == "Chest")
					{
						getChest();
					}
				}
				else
				{
					playerMoveHistory.push([0, 0]);
				}
				
				if (playerMoveHistory.length > 10)
				{
					playerMoveHistory.shift();
				}
				gameTurn();
				drawCanvas(map);
			}
			
			function forecastPlayerPosition()
			{
				forecastedPlayerPosition = [playerX, playerY];
				for (let i = 0; i < playerMoveHistory.length; i++)
				{
					forecastedPlayerPosition[0] = forecastedPlayerPosition[0] + playerMoveHistory[i][0];
					forecastedPlayerPosition[1] = forecastedPlayerPosition[1] + playerMoveHistory[i][1];
				}
				if (forecastedPlayerPosition[0] < 0)
				{
					forecastedPlayerPosition[0] += map.length;
				}
				else if (forecastedPlayerPosition[0] >= map.length)
				{
					forecastedPlayerPosition[0] -= map.length
				}
				if (forecastedPlayerPosition[1] < 0)
				{
					forecastedPlayerPosition[1] += map.length;
				}
				else if (forecastedPlayerPosition[1] >= map.length)
				{
					forecastedPlayerPosition[1] -= map.length
				}
			}
			
			function gameTurn()
			{
				buildPriorityMap(playerY, playerX, 0, []); //playerTargetted
				
				forecastPlayerPosition();
				buildPriorityMap(forecastedPlayerPosition[1], 
					forecastedPlayerPosition[0], 1, []); //playerForecasted
					
				buildPriorityMap(playerY, playerX, 2, monsterNames); //playerTargetted, avoiding all other monsters
				
				for (let i = 0; i < map.length; i++)
				{
					for (let j = 0; j < map[i].length; j++)
					{
						var mapEntity = map[i][j];
						if (monsterNames.includes(mapEntity))
						{
							moveMonster(mapEntity, i, j);
						}
					}
				}
			}
			
			var priorityMaps = [];
			priorityMaps.push([]); //playerTargeted
			priorityMaps.push([]); //playerForecasted
			priorityMaps.push([]); //playerTargeted, avoiding Monsters
			
			function buildPriorityMap(targetI, targetJ, priorityMapIndex, entitiesToAvoid)
			{
				priorityMaps[priorityMapIndex] = [];
				
				for (let i = 0; i < map.length; i++)
				{
					var row = [];
					for (let j = 0; j < map.length; j++)
					{
						row.push(map[i][j]);
					}
					priorityMaps[priorityMapIndex].push(row);
				}
				
				if (moveableTileNames.includes(map[targetI][targetJ]))
				{
					priorityMaps[priorityMapIndex][targetI][targetJ] = 0;
				}
				else
				{
					priorityMaps[priorityMapIndex][targetI][targetJ] = -1;
				}
				
				assignSpacePriority(targetI + 1, targetJ, 1, priorityMapIndex, entitiesToAvoid);
				assignSpacePriority(targetI - 1, targetJ, 1, priorityMapIndex, entitiesToAvoid);
				assignSpacePriority(targetI, targetJ + 1, 1, priorityMapIndex, entitiesToAvoid);
				assignSpacePriority(targetI, targetJ - 1, 1, priorityMapIndex, entitiesToAvoid);
				
				for (let i = 0; i < priorityMaps[priorityMapIndex].length; i++)
				{
					for (let j = 0; j < priorityMaps[priorityMapIndex].length; j++)
					{
						if (isNaN(parseInt(priorityMaps[priorityMapIndex][i][j])))
						{
							priorityMaps[priorityMapIndex][i][j] = -1;
						}
					}
				}
			}
			
			function compareSpacePriority(targetI, targetJ, testPriority, priorityMapIndex)
			{
				//This is used to determine if an adjacent space has already been prioritized.
				//If it has, and it has lower priority than we're testing, we'll use that +1
				//If it hasn't, we'll return the prio we're testing + 1, so that it won't be used
				if (targetI < 0)
				{
					targetI += map.length;
				}
				else if (targetI >= map.length)
				{
					targetI -= map.length;
				}
				if (targetJ < 0)
				{
					targetJ += map.length;
				}
				else if (targetJ >= map.length)
				{
					targetJ -= map.length;
				}
				var targetSpaceContents = priorityMaps[priorityMapIndex][targetI][targetJ];
				if ((!isNaN(parseInt(targetSpaceContents))) && (targetSpaceContents != -1))
				{
						return targetSpaceContents + 1;
				}
				else
				{
					return testPriority + 1;
				}
			}
			
			function assignSpacePriority(targetI, targetJ, newPriority, priorityMapIndex, entitiesToAvoid)
			{
				var adjustedNewPriority = newPriority;
				if (targetI < 0)
				{
					targetI += map.length;
				}
				else if (targetI >= map.length)
				{
					targetI -= map.length;
				}
				if (targetJ < 0)
				{
					targetJ += map.length;
				}
				else if (targetJ >= map.length)
				{
					targetJ -= map.length;
				}
				var targetSpaceContents = priorityMaps[priorityMapIndex][targetI][targetJ];
				if ((isNaN(parseInt(targetSpaceContents))) || ((targetSpaceContents > newPriority) && (targetSpaceContents != -1))) //this spaces hasn't been prioritized yet or it's been prioritized too high
				{
					if ((moveableTileNames.includes(targetSpaceContents))
						|| (monsterNames.includes(targetSpaceContents))
						|| (!isNaN(parseInt(targetSpaceContents))))
					{
						//Check all adjacent spaces, to see if they've been prioritized lower than this one will be prioritized. (to prevent snaking suboptimally due to iterating through map in order to prioritize)
						var adjacentPriority = compareSpacePriority(targetI + 1, targetJ, newPriority, priorityMapIndex);
						if (adjacentPriority < adjustedNewPriority)
						{
							adjustedNewPriority = adjacentPriority;
						}
						adjacentPriority = compareSpacePriority(targetI - 1, targetJ, newPriority, priorityMapIndex);
						if (adjacentPriority < adjustedNewPriority)
						{
							adjustedNewPriority = adjacentPriority;
						}
						adjacentPriority = compareSpacePriority(targetI, targetJ + 1, newPriority, priorityMapIndex);
						if (adjacentPriority < adjustedNewPriority)
						{
							adjustedNewPriority = adjacentPriority;
						}
						adjacentPriority = compareSpacePriority(targetI, targetJ - 1, newPriority, priorityMapIndex);
						if (adjacentPriority < adjustedNewPriority)
						{
							adjustedNewPriority = adjacentPriority;
						}
						
						if (entitiesToAvoid.includes(map[targetI][targetJ]))
						{
							adjustedNewPriority += 15;
						}
						priorityMaps[priorityMapIndex][targetI][targetJ] = adjustedNewPriority;
						assignSpacePriority(targetI + 1, targetJ, adjustedNewPriority + 1, priorityMapIndex, entitiesToAvoid);
						assignSpacePriority(targetI - 1, targetJ,  adjustedNewPriority + 1, priorityMapIndex, entitiesToAvoid);
						assignSpacePriority(targetI, targetJ + 1, adjustedNewPriority + 1, priorityMapIndex, entitiesToAvoid);
						assignSpacePriority(targetI, targetJ - 1, adjustedNewPriority + 1, priorityMapIndex, entitiesToAvoid);
					}
					else
					{
						priorityMaps[priorityMapIndex][targetI][targetJ] = -1;
					}
				}
			}
			
			function moveMonster(mapEntity, i, j)
			{
				var targetSpaces = [];
				var monsterPriorityMapIndex
				switch(mapEntity)
				{
					case "Ghost":
						if (priorityMaps[0][i][j] < 3)
						{
							monsterPriorityMapIndex = 0;
						}
						else
						{
							monsterPriorityMapIndex = 1;
						}
						break;
					/*case "Skeleton":
						break;*/
					default:
						monsterPriorityMapIndex = 2;
						break;
				}
				
				var i_minus = i - 1;
				if (i_minus < 0)
				{
					i_minus += map.length;
				}
				targetSpaces.push(
					{
						space_i: 		i_minus,
						space_j: 		j,
						space_priority:	priorityMaps[monsterPriorityMapIndex][i_minus][j]
					}
				);
				var i_plus = i + 1;
				if (i_plus >= map.length)
				{
					i_plus -= map.length;
				}
				targetSpaces.push(
					{
						space_i: 		i_plus,
						space_j: 		j,
						space_priority:	priorityMaps[monsterPriorityMapIndex][i_plus][j]
					}
				);
				var j_minus = j - 1;
				if (j_minus < 0)
				{
					j_minus += map.length;
				}
				targetSpaces.push(
					{
						space_i: 		i,
						space_j: 		j_minus,
						space_priority:	priorityMaps[monsterPriorityMapIndex][i][j_minus]
					}
				);
				var j_plus = j + 1;
				if (j_plus >= map.length)
				{
					j_plus -= map.length;
				}
				targetSpaces.push(
					{
						space_i: 		i,
						space_j: 		j_plus,
						space_priority:	priorityMaps[monsterPriorityMapIndex][i][j_plus]
					}
				);
				targetSpaces = sort_by_key(targetSpaces, 'space_priority');
				
				var new_i = i;
				var new_j = j;
				
				for (let x = 0; x < targetSpaces.length; x++)
				{
					targetI = targetSpaces[x].space_i;
					targetJ = targetSpaces[x].space_j;
					var targetSpaceContents = map[targetI][targetJ];
					if (targetSpaceContents == "Player")
					{
						monsterEatsPlayer(mapEntity, targetI, targetJ);
					}
					if (moveableTileNames.includes(targetSpaceContents))
					{
						map[targetI][targetJ] = mapEntity + "*"; //already moved
						map[i][j] = targetSpaceContents;
						x = targetSpaces.length;
					}
				}
			}
			
			function monsterEatsPlayer(monsterName, i, j)
			{
				if (testMode)
				{
					alert("You were eaten by a " + monsterName + "!");
				}
			}
			
			function drawCanvas(map)
			{
				var ghostLocations = [];
				for (let i = 0; i < map.length; i++)
				{
					for (let j = 0; j < map[0].length; j++)
					{
						if (map[i][j].includes("*"))
						{
							map[i][j] = map[i][j].substr(0, map[i][j].length - 1);
						}
						if (map[i][j] == "Ghost")
						{
							ghostLocations.push([i, j]);
						}
						ctx.drawImage(
							tileMapImg,
							tilePositions[map[i][j]].x*(tileSize + 2),
							tilePositions[map[i][j]].y*(tileSize + 2),
							tileSize, tileSize,
							i*tileSize,
							j*tileSize,
							tileSize, tileSize
						);
					}
				}
				
				if (testMode)
				{
					/*ctx.strokeStyle="blue";
					ctx.beginPath();
					ctx.moveTo(forecastedPlayerPosition[1] * tileSize, forecastedPlayerPosition[0] * tileSize);
					ctx.lineTo(playerY * tileSize, playerX * tileSize);
					ctx.stroke();	
					
					for (let i = 0; i < ghostLocations.length; i++)
					{
						ctx.strokeStyle="red";
						ctx.beginPath();
						ctx.moveTo(forecastedPlayerPosition[1] * tileSize, forecastedPlayerPosition[0] * tileSize);
						ctx.lineTo(ghostLocations[i][0] * tileSize, ghostLocations[i][1] * tileSize);
						ctx.stroke();	
					}*/
				}
			}
			
			function shuffle(array) { //from: https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
				var currentIndex = array.length, temporaryValue, randomIndex;

				// While there remain elements to shuffle...
				while (0 !== currentIndex) {

				// Pick a remaining element...
				randomIndex = Math.floor(Math.random() * currentIndex);
				currentIndex -= 1;

				// And swap it with the current element.
				temporaryValue = array[currentIndex];
				array[currentIndex] = array[randomIndex];
				array[randomIndex] = temporaryValue;
				}

				return array;
			}
			
			function sort_by_key(array, key) //from: https://stackoverflow.com/questions/8175093/simple-function-to-sort-an-array-of-objects/8175221#8175221
			{
			 return array.sort(function(a, b)
			 {
			  var x = a[key]; var y = b[key];
			  return ((x < y) ? -1 : ((x > y) ? 1 : 0));
			 });
			}
		</script>
	</body>
</html>
